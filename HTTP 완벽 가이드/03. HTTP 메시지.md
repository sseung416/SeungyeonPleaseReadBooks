# 03. HTTP 메시지

## (1) 메시지의 흐름
- 메시지는 항상 다운스트림으로 흐름
- 요청할 때는 클라이언트가 업스트림, 서버가 다운스트림이 되어 메시지가 흘러감
- 응답할 때는 서버가 업스트림, 클라이언트가 다운스트림이 되어 메시지가 흘러감

> 💬 메시지의 방향을 나타내는 용어들
> - **인바운드**: 메시지가 서버로 향하는 것 
> - **아웃바운드**: 메시지가 클라이언트로 돌아오는 것


## (2) 메시지 블럭
- 메시지는 단순 구조화된 블럭
- 시작줄, 헤더 블럭, 본문(body)으로 이뤄짐
- 시작줄과 헤더는 반드시 존재하지만, 본문은 비어있을 수 있음
### 메시지 문법
- 모든 메시지는 요청 메시지와 응답 메시지로 구분
  - 요청 메시지 형식
    ```
    <method> <requst URL> <version>
    <header>
    
    <entity body> 
    ```
    
  - 응답 메시지 형식 (시작줄만 달라짐)
    ```
    <version> <status code> <reason phrase>
    <header>
    
    <entity body> 
    ```
- 자세한 설명은 어차피 뒤에서 나오므로 아래를 살펴보자~

### 시작줄
#### 요청줄
- 서버에게 리소스에 대한 작업을 요청하는 역할
- 메서드, 요청 URL, HTTP 버전으로 구성
  - HTTP/1.0 이전에는 버전 값이 없음!
- 모든 필드는 공백으로 구분됨
#### 응답줄
- 요청 수행 결과
- HTTP 버전, 숫자 상태 코드, 사유 구절로 구성
- 모든 필드는 똑같이 공백으로 구분
#### 메서드(method)
- 서버가 리소스에 대해서 수행해주길 바라는 동작
- ex) `GET`, `POST` 등
- 메서드 종류에 따라 본문(body)가 없는 경우도 있음
- [HTTP 메서드 종류](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)
- 지원하는 메서드 이외에도 추가적으로 메서드를 구현할 수 있음 -> 확장 메서드
#### 상태 코드(status code)
- 클라이언트에게 알려주는 요청 수행의 상태 값
- 세 자리 숫자로 묶임 `ex) 200, 404`
- 상태 코드를 통해 클라이언트는 결과 상태에 맞는 이벤트 핸들링이 가능하다~
#### 사유 구절
- 상태 코드와 일대일로 대응되는 메시지
- 상태 코드의 사람이 이해하기 쉬운 버전
- 엄격한 규칙은 없음
  - ~~200 NOT OK 날려도 괜찮다는 뜻\~~~
#### 버전(version)
- 지원하는 HTTP의 버전 값
- 형식: `HTTP/<메이저>.<마이너>`
- 요청 및 응답 메시지 모두에 기술
  - 상대방에게 자신의 프로토콜 버전을 알려주기 위함!
- 버전 정보는 분수로 다뤄지지 않는다!
  - ex) `HTTP/2.22`는 `HTTP/2.3`보다 크다!
  
### 헤더
- 일반 헤더, 응답 헤더, 요청 헤더, 엔티티 헤더, 확장 헤더로 나뉨
- 자세한 건 아래에서~!

### 엔티티 본문
- 요청한 리소스의 값

### 버전 0.9 메세지
- 프로토콜의 초기 버전
- 매우 단순해 사용하기 어려웠음
  - 요청: 메서드, 요청 URL
  - 응답: ~~걍 노빠꾸~~ 엔티티
- 그런데.. 아직도 사용하는 애플리케이션이 있다고요..? ㄷㄷ


## (3) 메서드
HTTP 버전마다 지원되는 메서드가 다르므로 유의하도록 하자~
### 안전한 메서드(Safe Method)
- HTTP 요청을 실행했을 때, 서버의 어떠한 작용도 끼치지 않는 메서드를 의미
  - ex) GET, HEAD 등, POST 메서드와 같은 경우 데이터를 입력하므로 서버에 영향을 끼침
### HEAD
- `GET`과 비슷하지만, 응답으로 헤더만 반환하는 메서드
- 활용
  - 리소스의 타입을 알고자 할 때
  - 응답 코드를 통해 개체가 존재하는지 확인하고자 할 때
  - 헤더를 통해 리소스가 변경되었는지 검사하기 위해
- [추가] [GET 메서드와 HEAD 메서드의 성능 차이에 대해](https://stackoverflow.com/questions/16539269/http-head-vs-get-performance)
  - 요약하면, 리소스 크기가 작은 경우 HEAD 메서드가 더 빠를 수 있지만 그렇지 않은 경우 성능이 비슷하거나 오히려 느리다~
### PUT vs POST
- `PUT`: 서버에 직접 문서를 쓰는 작업
  - 주로 콘텐츠를 수정할 때 사용됨
  - 해당 URL가 존재하다면, body의 내용으로 교체하고 그렇지 않다면 새 파일을 생성함
- `POST`: 서버에 입력 데이터를 전송하기 위한 작업
  - HTML에서 폼을 지원하기 위해 사용됨
### TRACE
- 요청이 서버에게 도착했을 때 어떻게 보여지는지 클라이언트에게 알려주는 메서드

[//]: # (todo: trace 개념 정리 너무 눈에 안 들어 온다..)
### OPTIONS
- 메서드의 지원 범위를 요청하는 메서드 (어떤 메서드가 지원되는지~)

## (4) 상태 코드
크게 5가지로 나뉨  
상태 코드 종류는 너무나도 친절한 [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses) 를 참고하도록 하자~~
### 종류
- 100: 정보성 상태 코드
  - `HTTP/1.1`부터 도입 
- 200: 성공 상태 코드 
- 300: 리다이렉션 상태 코드
  - 리소스의 위치가 변경되었을 때, 이를 알려주기 위함
- 400: 클라이언트 에러 상태 코드
- 500: 서버 에러 상태 코드
### 100 Continue
- 요청의 일부분만 실행했으며, 클라이언트가 나머지를 계속 이어 보내야 함을 의미함
- 전송하기 전, 서버가 body 데이터를 받아들일 수 있는지 확인하려고 할 때, 확인 작업을 최적화하기 위해 설계됨(...)
- 대충 너무너무 복잡하다~

## (5) 헤더
### 일반 헤더
- 요청, 응답 양쪽 모두 나타날 수 있는 헤더
- ex) Date 헤더 `Date: Mon, 28 Aug 2023 02:16:00 GMT`
### 요청 헤더
- 요청 메시지를 위한 헤더
- 클라이언트가 서버에게 전달하고자 하는 부가 정보를 담음
- ex) Accept 헤더(미디어 타입을 나타냄) `Accepth: */*`
### 엔티티 헤더
- body와 관련된 정보를 담은 헤더
- ex) Content-Type 헤더(body의 데이터 타입을 나타냄) `Content-Type: application/json; charset=UTF-8 `
### 확장 헤더
- 개발자에 의해 새로 만들어진 헤더
- 비표준 헤더