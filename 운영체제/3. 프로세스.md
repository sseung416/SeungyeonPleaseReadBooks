# 3. 프로세스

## (1) 프로세스의 개념

### 프로그램
- 실행 파일
- 디스크에 저장된 명령어 리스트
- 수동적 존재(passive entity)

### 프로세스
- 실행 중인 프로그램
- 메모리에 적재된 프로그램
- 컴퓨팅 시스템에서의 작업의 단위
- 능동적인 존재(active entity)
- 프로세스의 상태는 프로그램 카운터(PC)와 프로세서 레지스터로 나타냄
- 운영체제가 해야하는 가장 기본적인 일이 이 프로세스 관리다~

### 프로세스의 메모리 배치 구조

<!-- 사진 -->
- 텍스트 영역: 실행 코드(명령어)
- 데이터 영역: 전역 변수, 초기화 데이터 영역과 bss로 한 번 더 나누기도 함
  - bss(block started symbol): 초기화되지 않은 데이터
- 힙 영역: 실행 중 동적으로 할당되는 메모리
- 스택 영역: 함수 호출 시 사용하는 임시 데이터 저장소

<br/>

설명

- 텍스트, 데이터 영역은 크기가 고정, 힙, 스택 영역은 동적으로 크기가 바뀜
- 힙과 스택 영역은 서로의 방향으로 커지기 때문에 운영체제에서 겹치지 않도록 관리가 필요
  - 활성화 레코드: 함수가 호출될 때마다 스택에 푸시되는 데이터, 매개변수, 지역 변수, 복귀 주소 등

### 프로세스의 상태
<!-- 사진   -->
프로세스는 실행되면서 상태가 변경됨
- 생성(New): 프로세스를 갓 생성한 상태
- 준비(Ready): 변수 초기화 등의 기초 준비 작업을 끝내고 바로 실행할 수 있는 상태, Ready Queue에 등록된 상태
- 실행(Running): 프로세스가 실행 중인 상태
- 대기(Waiting): 다른 프로세스가 실행 중이라, 인터럽트 등 이벤트가 일어날 때까지 대기하는 상태
- 종료(Terminated): 프로세스가 종료된 상태

### 프로세스 제어 블럭, PCB
- 프로세스와 관련된 정보를 나타내는 구조체
- PCB(process control block), 태스크 제어 블럭이라고도 불림
- 프로세스 생성 시 함께 생성되며, 실행 중이지 않을 때는 보조 기억 장치에 저장됨
- 운영체제는 PCB를 통해 프로세스를 관리

<br/>
<!-- PCB 블럭 사진 -->
PCB 블럭 구성요소

- 프로세스 상태
- 프로그램 카운터: 다음에 실행할 명령어 주소
- CPU 레지스터: 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드
- CPU 스케줄링 정보: 프로세스 우선 순위, 스케줄 큐의 포인터 등
- 메모리 관리 정보: base register, limit register
- 회계(account) 정보: CPU 사용 시간, 시간 제한, 계정 번호 등
- 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록


## (2) 프로세스 스케줄링

### 기초
- 다중 프로그래밍의 목적: CPU 이용의 최대화 => 항상 어떤 프로세스를 실행하도록 하자!
- 시분할의 목적: 용이한 사용자 경험 => CPU 코어를 빈번하게 교체하자!
- 프로세스 스케줄러: 실행가능한 여러 프로세스 중 하나를 선택함
- 다중 프로그래밍 정도: 현재 메모리에 있는 프로세스 수

### 스케줄링 큐
- 준비 큐(ready queue): 프로세스가 준비 상태에 되었을 때에 삽입되는 큐
  - 연결 리스트 형태, 포인터 필드가 포함됨
  - 포인터 필드: ready queue의 다음 PCB를 가리키는 포인터
  - 새 프로세스는 ready queue에서 디스패치될 때까지(실행될 때까지~) 대기함
- 대기 큐(wait queue): 입출력, 시간 초과 등 인터럽트가 발생했을 때에 삽입되는 큐
  - I/O completion이나 이벤트가 발생할 때까지 대기
  - 한 프로세스가 CPU를 너무 오래 점유 중(시간 초과)이라면 인터럽트되어 wait queue로 돌아갈 수 있음~

### CPU 스케줄링
- CPU 스케줄러의 역할: ready queue의 프로세스 중 CPU 코어에 할당할(실행할) 프로세스를 고르는 것
- I/O 바운드 프로세스: 계산보다 입출력에 시간 소비하는 프로세스
- CPU 바운드 프로세스: 입출력보다 계산에 시간 소비하는 프로세스
- 스와핑(swapping): CPU에 적재한 프로세스와 보조기억장치에 적재한 다른 프로세스의 메모리를 교체하는 기법 (뒤에 나오니 그만 알아보도록 하자)

### Context Switching

  

## (3) 연산


## (4) 프로세스 간 통신, IPC
- 실행되는 프로세스의 종류
  - 독립적 프로세스: 다른 프로세스와 데이터를 공유하지 않는 프로세스
  - 협력적 프로세스: 다른 프로세스와 데이터를 공유하는 프로세스, 다른 프로세스로부터 영향을 받는 프로세스
- 프로세스의 협력을 제공하는 이유
  - 정보 공유
  - 계산 가속화: 서브태스크를 나누어 실행하기 때문에 속도가 빠름
  - 모듈성
- 프로세스 간 통신(IPC, interprocess communication)의 종류: 공유 메모리, 메시지 전달


## (5) 공유 메모리
### 공유 메모리
- 협력 프로세스들에 의해 공유되는 메모리 영역
- 처음 구축할 때만 시스템이 필요하고, 이후에는 커널의 도움이 필요 없음
- 기본적으로 프로세스 내부 공간에 다른 프로세스가 접근하지 못함
- 두 프로세스 간 공유 메모리를 구축한다 => 위 제약 조건을 제거한다는 의미
- 형식과 위치는 프로세스에 의해 결정됨, 운영체제 소관 X

### 생산자-소비자 문제

### 버퍼
- 생산자-소비자 문제를 해결하는 해결책 중 하나
- 공유 메모리 내부에 존재
- 버퍼는 `in`(다음으로 빈 위치), `out`(1번째로 채워진 위치)의 2개의 논리 포인터로 구성된 원형 배열로 구현됨
  - empty: `in == out`
  - full: `(in+1)%BUFFER_SIZE == out`
- 종류
  - 무한 버퍼(unbounded buffer): 크기의 한계가 없는 버퍼
  - 유한 버퍼(bounded buffer): 크기가 고정된 버퍼, 비어있을 때 소비자가 대기, 꽉 차 있을 때 생산자가 대기

## (6) 메시지 전달 시스템
### 메세지 전달 방식
- 주소 공간을 공유하지 않고 통신하는 방법
- 분산 시스템에서 유용
- 장점: 충돌 회피가 필요 없어, 적은 양의 데이터 교환에 용이
- 단점: 메세지 관리를 위한 지속적인 커널 간섭 필요

### 메세지의 종류
- 고정 길이 메시지
  - 직선적(쉬운) 시스템 구현
  - 프로그래밍할 때 힘들어...
- 가변 길이 메시지
  - 복잡한 시스템 구현
  - 프로그래밍할 때 쉬워!

### 통신 연결의 종류
메시지 전달을 위해서는 각 프로세스 간 연결되어야 함
- 직접/간접 통신
- 동기/비동기식 통식
- 자동/명시적 버퍼링

### 직접 통신
- 프로세스의 이름을 직접 명시하여 메세지를 전달하는 방법
- 연결이 자동으로 구축됨, 각 프로세스는 통신할 프로세스의 identity만 알면 됨
- 정확히 두 프로세스 사이에만 연결되며, 하나의 연결만 존재
- 단점: 하드 코딩 기법이기 때문에 프로세스의 이름이 변경되면 재검사 필요 => 모듈성 제한!
- 대칭적 방식
```
send(P, message) - 프로세스 P에 메세지 송신
receive(Q, message) - 프로세스 Q로부터 메세지 수신
```
- (변형) 비대칭적 방식: 송신자만 수신자의 이름을 명시
```
send(P, message) - 프로세스 P에 메세지 송신
receive(id, message) - 메세지 수신 (id=PID)
```

### 간접 통신
- 메일박스(포트)를 사용해 메세지를 전달하는 방식
- 프로세스가 공유 메일박스를 가질 때 연결 구축
- 2개 이상 프로세스 연결 가능
- 여러 프로세스 사이 다수의 연결이 있을 수 있고, 각 연결은 하나의 메일박스에 대응
- 여러 프로세스 사이 어떤 프로세스에게 메세지를 수신할지 결정하는 알고리즘 필요
```
send(A, message) - 메일박스 A로 메세지 송신
receive(A, message) - 메일박스 A로 메세지 수신
```

#### 메일박스
- 메세지가 저장되고 제거될 수 있는 객체
- 각각 고유의 id를 가짐
- 프로세스나 운영체제에 의해 소유
- 프로세스 소유
  - 수신만 가능한 프로세스인 소유자와 송신만 가능한 프로세스인 사용자로 구분 => 송수신 메세지에 대한 혼란 없음!
  - 프로세스가 종료될 때 사라짐 => 모든 프로세스에게 해당 메일박스가 사라졌다는 통보 필요
- 운영체제 소유
  - 독립적
  - 프로세스에 메일박스 관리 기법 제공: 메일 박스 생성, 메시지 송수신, 메일 박스 삭제

### 동기화
- 동기식(blocking)
  - 보내기: 메세지를 수신할 때까지 송신 프로세스를 blocking
  - 받기: 메세지가 받을 때까지 수신 프로세스를 blocking
- 비동기식(nonblocking)
  - 보내기: 바로 수신
  - 받기: 메세지 또는 null을 받음
  - 소비자-생산자 문제의 쉬운 해결책~~

### 버퍼링
- 버퍼가 없는 메시지 시스템(무용량)과 자동 버퍼링 시스템(유/무한 용량)으로 나뉨
- 무용량: 최대 길이가 0인 큐
  - 메시지를 가질 수 없음
- 유한 용량: 유한한 길이의 큐
  - 큐가 꽉 찼을 때만 blocking됨
- 무한 용량: 무한한 길이의 큐
  - 메시지를 계속 보낼 수 있다 => 송신자는 절대 blocking되지 않음

## (7) IPC 시스템의 사례

## (8) 클라이언트 서버 환경에서 통신